// File: app/src/main/java/com/example/runningtracker/service/TrackingService.ktpackage com.example.runningtracker.serviceimport android.app.NotificationChannelimport android.app.NotificationManagerimport android.app.PendingIntentimport android.app.Serviceimport android.content.Contextimport android.content.Intentimport android.content.SharedPreferencesimport android.hardware.Sensorimport android.hardware.SensorEventimport android.hardware.SensorEventListenerimport android.hardware.SensorManagerimport android.location.Locationimport android.location.LocationListenerimport android.location.LocationManagerimport android.os.Buildimport android.os.Bundleimport android.os.IBinderimport android.util.Logimport androidx.core.app.NotificationCompatimport com.example.runningtracker.Rimport com.example.runningtracker.ui.main.MainActivityimport com.example.runningtracker.utils.HybridDistanceCalculatorclass TrackingService : Service() {    private lateinit var locationManager: LocationManager    private lateinit var sensorManager: SensorManager    private var stepSensor: Sensor? = null    private var isTracking = false    private lateinit var hybridCalculator: HybridDistanceCalculator    private var lastLocation: Location? = null    private var initialStepCount = -1    // --- ДОБАВЛЕНО: SharedPreferences ---    private lateinit var sharedPreferences: SharedPreferences    private val PREFS_NAME = "TrackingPrefs"    private val DISTANCE_KEY = "current_distance"    // --- КОНЕЦ ДОБАВЛЕНИЯ ---    private val TAG = "TrackingService"    private val locationListener = object : LocationListener {        override fun onLocationChanged(location: Location) {            Log.d(TAG, "onLocationChanged вызван, координаты: ${location.latitude}, ${location.longitude}, точность: ${location.accuracy}")            Log.d(TAG, "Расстояние до addGpsLocation: ${hybridCalculator.getTotalDistance()}")            hybridCalculator.addGpsLocation(location)            lastLocation = location            Log.d(TAG, "Расстояние после addGpsLocation: ${hybridCalculator.getTotalDistance()}")            Log.d(TAG, "Расстояние от шагов: ${hybridCalculator.getStepBasedDistance()}")            Log.d(TAG, "Расстояние от GPS: ${hybridCalculator.getGpsBasedDistance()}")            // sendLocationUpdateBroadcast() // Закомментируем старый способ            updateSharedDistance() // --- ДОБАВЛЕНО: вызов метода обновления SharedPreferences ---        }        override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) {            Log.d(TAG, "onStatusChanged вызван, провайдер: $provider, статус: $status")        }        override fun onProviderEnabled(provider: String) {            Log.d(TAG, "onProviderEnabled вызван, провайдер: $provider")        }        override fun onProviderDisabled(provider: String) {            Log.d(TAG, "onProviderDisabled вызван, провайдер: $provider")        }    }    private val stepCounterListener = object : SensorEventListener {        override fun onSensorChanged(event: SensorEvent?) {            event?.let {                val newStepCount = it.values[0].toInt()                Log.d(TAG, "onSensorChanged (шаги), текущие шаги: $newStepCount")                if (initialStepCount == -1) {                    // Сохраняем начальное значение при первом вызове                    initialStepCount = newStepCount                    Log.d(TAG, "Сохранено начальное значение шагов: $initialStepCount")                }                // Вычисляем шаги, сделанные за сессию                val stepsInSession = newStepCount - initialStepCount                Log.d(TAG, "Шагов за сессию: $stepsInSession")                // Обновляем шаги в калькуляторе                hybridCalculator.updateSteps(stepsInSession)                Log.d(TAG, "Расстояние после updateSteps: ${hybridCalculator.getTotalDistance()}")                Log.d(TAG, "Расстояние от шагов: ${hybridCalculator.getStepBasedDistance()}")                Log.d(TAG, "Расстояние от GPS: ${hybridCalculator.getGpsBasedDistance()}")                // sendLocationUpdateBroadcast() // Закомментируем старый способ                updateSharedDistance() // --- ДОБАВЛЕНО: вызов метода обновления SharedPreferences ---            }        }        override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {            Log.d(TAG, "onAccuracyChanged вызван, сенсор: ${sensor?.name}, точность: $accuracy")        }    }    override fun onCreate() {        super.onCreate()        Log.d(TAG, "onCreate вызван")        hybridCalculator = HybridDistanceCalculator(stepLength = 0.75)        // --- ДОБАВЛЕНО: инициализация SharedPreferences ---        sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)        // --- КОНЕЦ ДОБАВЛЕНИЯ ---        createNotificationChannel()    }    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {        Log.d(TAG, "onStartCommand вызван")        startForeground(1, createNotification().build())        startTracking()        return START_STICKY    }    override fun onBind(intent: Intent?): IBinder? = null    private fun startTracking() {        Log.d(TAG, "startTracking вызван")        locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager        stepSensor = sensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER)        var hasGps = false        var hasStepCounter = false        // Проверка разрешений и запуск GPS        if (checkSelfPermission(android.Manifest.permission.ACCESS_FINE_LOCATION) == android.content.pm.PackageManager.PERMISSION_GRANTED) {            Log.d(TAG, "Разрешение ACCESS_FINE_LOCATION получено, запрашиваем обновления GPS")            locationManager.requestLocationUpdates(                LocationManager.GPS_PROVIDER,                1000L, // 1 секунда                1f,    // 1 метр                locationListener            )            hasGps = true            Log.d(TAG, "requestLocationUpdates для GPS вызван успешно")        } else {            Log.e(TAG, "Нет разрешения ACCESS_FINE_LOCATION для GPS. Останавливаем сервис.")            stopSelf()            return        }        // Проверка наличия датчика шагов и его регистрация        if (stepSensor != null) {            Log.d(TAG, "Датчик шагов найден, регистрируем слушателя")            sensorManager.registerListener(stepCounterListener, stepSensor, SensorManager.SENSOR_DELAY_UI)            hasStepCounter = true            Log.d(TAG, "Слушатель шагов зарегистрирован")        } else {            Log.w(TAG, "Датчик шагов не найден на устройстве")        }        if (!hasGps && !hasStepCounter) {            Log.e(TAG, "Ни GPS, ни датчик шагов недоступны. Останавливаем сервис.")            stopSelf()            return        }        isTracking = true        Log.d(TAG, "startTracking завершён, isTracking = true")    }    private fun stopTracking() {        Log.d(TAG, "stopTracking вызван")        if (::locationManager.isInitialized) {            locationManager.removeUpdates(locationListener)            Log.d(TAG, "removeUpdates для GPS вызван")        }        if (::sensorManager.isInitialized && stepSensor != null) {            sensorManager.unregisterListener(stepCounterListener, stepSensor)            Log.d(TAG, "unregisterListener для шагов вызван")        }        isTracking = false        Log.d(TAG, "isTracking = false")        // stopSelf() вызывается в onDestroy    }    // --- ДОБАВЛЕНО: метод для обновления расстояния в SharedPreferences ---    private fun updateSharedDistance() {        val distance = hybridCalculator.getTotalDistance()        sharedPreferences.edit().putFloat(DISTANCE_KEY, distance.toFloat()).apply()        Log.d(TAG, "Расстояние обновлено в SharedPreferences: $distance")    }    // --- КОНЕЦ ДОБАВЛЕНИЯ ---    // --- ЗАКОММЕНТИРОВАНО: старый метод отправки broadcast ---    /*    private fun sendLocationUpdateBroadcast() {        val broadcastIntent = Intent("LOCATION_UPDATE").apply {            putExtra("distance", hybridCalculator.getTotalDistance())        }        sendBroadcast(broadcastIntent)        Log.d(TAG, "Broadcast отправлен с расстоянием: ${hybridCalculator.getTotalDistance()}")    }    */    // --- КОНЕЦ КОММЕНТАРИЯ ---    private fun createNotification(): NotificationCompat.Builder {        val intent = Intent(this, MainActivity::class.java).apply {            flags = Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_CLEAR_TOP        }        val pendingIntentFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT        } else {            PendingIntent.FLAG_UPDATE_CURRENT        }        val pendingIntent = PendingIntent.getActivity(            this, 0, intent, pendingIntentFlags        )        return NotificationCompat.Builder(this, "TRACKING_CHANNEL")            .setContentTitle("Отслеживание пробежки")            .setContentText("Дистанция: ${String.format("%.2f", hybridCalculator.getTotalDistance())} км")            .setSmallIcon(R.drawable.ic_run_notification)            .setContentIntent(pendingIntent)            .setOngoing(true)            .setOnlyAlertOnce(true)    }    private fun createNotificationChannel() {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {            val channel = NotificationChannel(                "TRACKING_CHANNEL",                "Отслеживание пробежки",                NotificationManager.IMPORTANCE_LOW            ).apply {                description = "Канал для уведомлений во время отслеживания пробежки"                setShowBadge(false)            }            val manager = getSystemService(NotificationManager::class.java)            manager.createNotificationChannel(channel)            Log.d(TAG, "NotificationChannel создан")        }    }    override fun onDestroy() {        super.onDestroy()        Log.d(TAG, "onDestroy вызван")        stopTracking()    }}